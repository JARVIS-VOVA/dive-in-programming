=begin
  В большинстве языков множества напрямую не реализованы (Pascal составляет исключение).
  Но массивы в Ruby обладают некоторыми свойствами, которые позволяют использовать их как множества.
  В данном разделе мы рассмотрим эти свойства и добавим свои собственные.

  В последних версиях Ruby стандартная библиотека содержит класс Set.
  Если вам приходится часто иметь дело с множествами, подумайте об использовании объектов Set вместо массивов.
  Этот класс рассмотрен в главе 9.

  Массив нельзя назвать идеальным средством для представления множества, поскольку он может содержать дубликаты.
  Если вы хотите трактовать массив как множество, то дубликаты можно удалить (с помощью метода uniq или uniq!).

  Над множествами производятся две основные операции: объединение и пересечение.
  Для этого применяются операторы | (или) и & (и) соответственно.
  Поскольку множество по определению не содержит дубликатов, то повторяющиеся элементы удаляются
  (вопреки ожиданиям тех, кому доводилось работать с объединением и пересечением массивов в других языках).
=end

a = [1, 2, 3, 4, 5]
b = [3, 4, 5, 6, 7]
p с = a | b # [1, 2, 3, 4, 5, 6, 7]
p d = a & b # [3,4,5]
# Дубликаты удаляются...
e = [1, 2, 2, 3, 4]
f = [2, 2, 3, 4, 5]
p g = e & f # [2; 3, 4]





=begin
  Для объединения множеств можно использовать и оператор конкатенации (+), но он не удаляет дубликаты.
  Метод `-` соответствует операции «разность множеств»;
  результатом является множество, куда входят те элементы первого множества, которые не являются элементами второго (см. раздел 8.1.12).
=end

а = [1, 2, 3, 4, 5]
b = [4, 5, 6, 7]
p с = а - b # [1, 2, 3]

# Отметим, что наличие элементов 6 and 7 не отражается на результате.

# Для «аккумулирования» множеств можно применять оператор |=

а = [1, 2, 3, 4, 5]
b = [4, 5, 6, 7]
p с = а - b # [1, 2, 3]

# как и следовало ожидать, а |= b — то же самое, что а = а | b
# Аналогичным образом оператор &= последовательно «сужает» множество.

# Для массивов не определена операция ИСКЛЮЧАЮЩЕЕ ИЛИ, но мы можем без труда реализовать ее.
# В терминах теории множеств она соответствует выборке тех элементов, которые входят в объединение двух множеств, но не входят в их пересечение.

class Array
  def ^(other)
    (self | other) - (self & other)
  end
end

x = [1, 2, 3, 4, 5]
y = [3, 4, 5, 6, 7]
p z = x ^ y # [1, 2, 6, 7]


# Чтобы проверить, входит ли некий элемент в множество, пользуйтесь методом include? или member?
# (синоним, подмешанный из модуля Comparable)

x = [1, 2, 3]

if x.include? 2
  puts "yes" # Печатается "yes"
else
  puts "no"
end

# ----------

class Object
  def in(other)
    other.include? self
  end
end

x = [1, 2, 3]

if 2.in x
  puts "yes" # Печатается "yes"
else
  puts "no"
end

# ----------



# Теперь обратимся к подмножествам и надмножествам.
# Как определить, является ли данное множество подмножеством или надмножеством другого?
# Встроенных методов для этого нет, но мы можем поступить следующим образом:

class Array
  def subset?(other)
    self.each do |x|
      if !(other.include? x)
        return false
      end
    end
    true
  end

  def superset?(other)
    other.subset?(self)
  end
end

a = [1, 2, 3, 4]
b = [2, 3]
c = [2, 3, 4, 5]

p flag1 = c.subset?(a)    # false
p flag2 = b.subset?(a)    # true
p flag3 = c.superset?(b)  # true

# Обратите внимание: мы выбрали «естественный» порядок, то есть задаем вопрос x.subset? у — «является ли x подмножеством у?», а не наоборот.

# ----------

# Для распознавания пустого множества достаточно проверить, пуст ли массив. Это делает метод empty?
# Операция дополнения опирается на идею универсального множества.
# Однако «универсальное множество» в каждой конкретной ситуации определяется по-разному,
# поэтому лучшим решением будет самое простое: сначала определим, что такое универсальное множество, а потом вычислим разность.


universe = [1, 2, 3, 4, 5, 6]
а = [2, 3]
p b = universe - а # Дополнение а = [1, 4, 5, 6]
