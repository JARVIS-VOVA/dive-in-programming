# Стеки и очереди — это первые из встретившихся нам структур, которые, строго говоря, не встроены в Ruby.
# Иными словами, в Ruby нет классов Stack и Queue, в отличие от Array и Hash
# (впрочем, класс Queue есть в библиотеке thread.rb, которую мы еще будем рассматривать).
#
# И все же в некотором смысле они встроены в Ruby.
# Ведь класс Array реализует всё, что нужно для того, чтобы рассматривать его как стек или очередь.
# Стек организован по принципу «последним пришел, первым обслужен» (LIFO — last-in first-out).
# Традиционный пример — стопка подносов на подпружиненной подставке в кафетерии: подносы кладутся сверху и сверху же снимаются.
#
# Над стеком можно выполнять ограниченный набор операций.
# Как минимум операции заталкивания (push) и выталкивания (pop), то есть помещения в стек и извлечения из него.
# Обычно также предоставляется способ проверить, пуст ли стек, и исследовать верхний элемент, не извлекая его из стека.
# Но никогда реализация не позволяет получить доступ к элементу в середине стека.
#
# Как же реализовать стек на базе массива, если к элементам массива можно обращаться в произвольном порядке, а стек таким свойством не обладает? Ответ прост.
# Стек — более абстрактная структура, чем массив.
# Он является стеком лишь до тех пор, пока мы обращаемся с ним как с таковым.
# В тот момент, когда вы пытаетесь обратиться к элементу недопустимым образом, стек перестает быть стеком.
#
# Но можно без труда определить класс Stack так, что к элементам можно будет обращаться только законно.
# И мы покажем, как это сделать.
#
# Стоит отметить, что во многих алгоритмах стек применяется как основа элегантного рекурсивного решения.
# Причина станет ясна, если чуточку подумать.
# При вызове функции или метода параметры заталкиваются в системный стек и выталкиваются из него при возврате.
# Таким образом, рекурсивный алгоритм просто подменяет явно определенный пользователем стек системным.
# Что лучше? Зависит от того, какое значение вы придаете понятности программы, ее эффективности и другим аспектам.
#
# --- Очередь ---
# 
# Очередь организована по принципу «первым пришел, первым обслужен» (FIFO — first-in first-out).
# Аналогом может служить очередь за билетами в театр: вновь подходящие становятся в конец очереди, а те, кто пришел раньше, обслуживаются первыми.
# В программировании очереди используются реже, чем стеки.
#
# Очереди полезны в системах реального времени, когда события нужно обрабатывать в порядке возникновения.
# Находят они применение и в ситуации «производитель-потребитель» (особенно в многопоточных программах и многозадачных средах).
# Неплохой пример — очередь к принтеру: задания на печать помещаются в один конец и ожидают, пока не будут извлечены с другого конца.
#
# Две основные операции над очередью называются «поместить» (enqueue) и «извлечь» (dequeue).
# Им соответствуют методы unpush и shift в классе Array.
#
# Отметим, что метод unshift может использоваться в сочетании с shift при реализации массива,
# но никак не очереди, поскольку unshift добавляет элемент в тот же конец массива, из которого shift его удаляет.
# С помощью различных комбинаций этих методов можно реализовать и стек, и очередь, но рассматривать все возможные сочетания мы не будем.
#
# На этом мы закончим введение в стеки и очереди.
# Самое время рассмотреть некоторые примеры.
