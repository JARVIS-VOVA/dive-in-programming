# В классе Hash есть методы класса [] и []=
# Используются они почти так же, как одноименные методы в классе Array, но принимают лишь один параметр.
# В качестве параметра может выступать любой объект, а не только строка (хотя строки используются чаще всего).

а = {}
p а["flat"] = 3       # {"flat"=>3}
p а.[]=("curved",2)   # {"flat"=>3,"curved"=>2}
p а.store("angled",5) # {"flat"=>3,"curved"=>2,"angled"=>5}
p а

# Метод store — просто синоним []=, оба могут принимать два аргумента, как показано в примере выше.

# Метод fetch аналогичен методу [], но возбуждает исключение IndexError, когда ключ отсутствует.
# Есть у него и необязательный второй аргумент (или блок) для указания значения по умолчанию

p а["flat"]       # 3
p а.[]("flat")    # 3
p а.fetch("flat") # 3
p а["bent"]       # nil
p а.fetch("bent", "asd") # asd

# Предположим, что мы не уверены, существует ли объект Hash, но хотели бы избежать очистки имеющегося хэша.
# Очевидное решение — проверить, определен ли интересующий нас объект

unless defined? а
  а={}
end

а["flat"] = 3

# Но есть и другой способ:

p а ||= {}
p а["flat"] = 3
# Или даже так:
p (а ||= {})["flat"] = 3

# Тот же вопрос можно поставить для отдельных ключей, когда новое значение следует присваивать, лишь если такого ключа еще нет:

а = Hash.new(99)
p а[2]       # 99
p а          # {}
p а[2] ||= 5 # 99
p а          # {}

b=Hash.new
p b          # {}
p b[2]       # nil
p b[2] ||= 5 # 5
p b          # {2=>5}

# Отметим, что nil может выступать и в качестве ключа, и в качестве значения:

p b={}
p b[2]      # nil
p b[3]=nil
p b         # {3=>nil}
p b[2].nil? # true
p b[3].nil? # true
p b[nil]=5
p b         # {3=>nil,nil=>5}
p b[nil]    # 5
p b[b[3]]   # 5
