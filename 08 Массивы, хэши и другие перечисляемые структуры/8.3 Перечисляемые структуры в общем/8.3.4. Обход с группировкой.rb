=begin
  До сих пор мы обходили список по одному элементу за раз. Но иногда желательно на каждой итерации анализировать по два, три или более элементов.

  Итератор each_slice принимает в качестве параметра число n, равное числу просматриваемых на каждой итерации элементов.
  (Для работы с ним нужна библиотека enumerator.)
  Если не осталось достаточного количества элементов, размер последнего фрагмента будет меньше.
=end

require 'enumerator'

arr = [1,2,3,4,5,6,7,8,9,10]

arr.each_slice(3) do |triple|
 puts triple.join(",")
end

# Выводится:
# 1,2,3
# 4,5,6
# 7,8,9
# 10

=begin
  Имеется также итератор each_cons, который позволяет обходить набор методом «скользящего окна» заданного размера.
  (Если название кажется вам странным, знайте, что это наследие языка Lisp.)
  В таком случае фрагменты всегда будут иметь одинаковый размер.
=end

arr = [1,2,3,4,5,6,7,8,9,10]

arr.each_cons(3) do |triple|
 puts triple.join(",")
end

# Выводится:
# 1,2,3
# 2,3,4
# 3,4,5
# 4,5,6
# 5,6,7
# 6,7,8
# 7,8,9
# 8,9,10
